import os
import torch
import cv2
import json
from flask import Flask, request, jsonify
from PIL import Image
import numpy as np
from ultralytics import YOLO
from collections import OrderedDict
from threading import Thread

app = Flask(__name__)

# ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• YOLO
model_path = 'pt_model/best.pt'
model = YOLO(model_path)

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
def send_results_to_user(results):
    print(f"üì§ ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {results}")
    # ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô WebSocket ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏µ‡πÄ‡∏°‡∏•)


# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
def predict_image(image_path):
    image = Image.open(image_path).convert("RGB")
    image = np.array(image)

    # ‡πÉ‡∏ä‡πâ YOLO ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
    results = model.predict(source=image, imgsz=640, conf=0.7)

    result_data = []
    
    if results and hasattr(results[0], 'boxes'):
        for det in results[0].boxes:
            class_idx = int(det.cls)
            class_name = model.model.names[class_idx]  # ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô KeyError
            confidence = det.conf.item()* 100
            xmin, ymin, xmax, ymax = det.xyxy[0].tolist()

            result_data.append(OrderedDict([
                ("class", class_name),
                ("confidence", f"{confidence:.2f}%"),
                ("bbox", [xmin, ymin, xmax, ymax])
            ]))
    else:
        result_data.append(OrderedDict([
            ("class", "NG"),
            ("confidence","0.00%"),
            ("bbox", [0, 0, 0, 0])
        ]))

    return result_data, results

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏†‡∏≤‡∏û
def process_predictions(image_names, image_directory, save_directory):
    all_results = []

    for image_name in image_names:
        image_path = os.path.join(image_directory, image_name)

        if not os.path.exists(image_path):
            all_results.append({
                "image": image_name,
                "status": "‚ùå ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"
            })
            continue

        # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
        result_data, results = predict_image(image_path)


        save_image_with_prediction(image_name, results, save_directory, result_data)

        # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
        all_results.append({
            "image": image_name,
            "results": result_data
        })

    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå JSON
    result_file = os.path.join(save_directory, "prediction_results.json")
    with open(result_file, 'w') as f:
        json.dump(all_results, f, indent=4)

    print(f"‚úÖ ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏µ‡πà: {result_file}")

    # ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
    send_results_to_user(all_results)



# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
def save_image_with_prediction(image_name, prediction, save_dir, result_data):
    jpg_dir = os.path.join(save_dir, 'jpg')
    json_dir = os.path.join(save_dir, 'json')
    txt_dir = os.path.join(save_dir, 'txt')

    for directory in [jpg_dir, json_dir, txt_dir]:
        os.makedirs(directory, exist_ok=True)

    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
    annotated_image = prediction[0].plot(line_width=1)
    annotated_image_rgb = cv2.cvtColor(annotated_image, cv2.COLOR_BGR2RGB)

    jpg_save_path = os.path.join(jpg_dir, image_name)
    cv2.imwrite(jpg_save_path, annotated_image_rgb)

    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô TXT
    txt_save_path = os.path.join(txt_dir, image_name.replace('.jpg', '.txt'))
    with open(txt_save_path, 'w') as f:
        for item in result_data:
            f.write(f"{item}\n")

    # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô JSON
    json_save_path = os.path.join(json_dir, image_name.replace('.jpg', '.json'))
    with open(json_save_path, 'w') as f:
        json.dump(result_data, f, indent=4)

    return jpg_save_path, txt_save_path, json_save_path


@app.route('/predict', methods=['POST'])
def predict():
    image_directory = r'\\10.63.85.5\image'
    save_directory = r'./predictions'

    try:
        data = request.json

        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ JSON ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if 'image_names' not in data or not isinstance(data['image_names'], list):
            return jsonify({"error": "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á"}), 400

        image_names = data['image_names']
        print(f"üì• ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß: {image_names}")

        # ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
        response = jsonify({"message": f"üì• ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢...."})
        response.status_code = 200

        # ‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÉ‡∏ô Background
        thread = Thread(target=process_predictions, args=(image_names, image_directory, save_directory))
        thread.start()

        return response  # ‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢

    except Exception as e:
        return jsonify({"error": str(e)}), 500


if __name__ == '__main__':
    app.run(debug=True)
